//*********************************************************************************
// Honor Code: The work I am submitting is a result of my own thinking and efforts.
// Michael Camara
// CMPSC 220 Fall 2015 (Professor Roos)
// Lab # 1
// Date: 9/10/15
// 
// Purpose: Understanding the Java compiler and bytecode
//
//*******************************************************************************

Part 4 (Java Experiment 2):
There appear to be two ways that the Java bytecode assigns double constants to double variables.  The dconst_0 and dconst_1 commands assign the values 0.0 and 1.0 to such a variable, respectively; while ldc2_w seems to be used to assign any other valid value to a double variable.  When an int value is assigned to a double variable, then the bytecode shows that a widening conversion has occurred by adding a ".0" to the end of the value (e.g. 5 in the source code converts to 5.0 in the bytecode).

Part 5 (Speculate):
The Java compiler likely uses a variety of assignment instructions in order to reduce time and space overhead for the program.  For instance, the int values ranging from -1 to 5 are controlled by the iconst instruction due to the great frequency that they are used.  Having a reserved instruction for these constants ensures that the operation happens quickly and with very small memory allocation.  Similarly, by separating sipush, bipush, ldc, and ldc2_w, the compiler can assign a value to the smallest space in memory possible that can still hold it.  If the compiler instead used ldc2_w for every single value, then there would be very large gaps in the memory due to small values occupying huge spaces, which would serve no purpose in the final program besides wasting space.

Part 6 (Java Experiment 3):
Each of the simple arithmetic operations for integer variables have their own command in the bytecode: iadd for addition, imul for multiplication, isub for subtraction, and idiv for division.  Immediately prior to these commands are iload statements to obtain the values of the integer variables, followed by an istore statement to store the new value in the indicated variable.

    // Bytecode example.  Note: int a = 6, b = 2;
    iload_1
    iload_2
    iadd        // int iSum = a + b;
    istore_3

    iload_1
    iload_2
    imul        // int iProduct = a * b;
    istore 4

    iload_1
    iload_2
    isub        // int iDifference = a - b;
    istore 5

    iload_1
    iload_2
    idiv        // int iQuotient = a / b;
    istore 6

Part 7 (Java Experiment 4)
The Java compiler does perform constant folding with declared constants or literal values:

    // Source code
    final int CONSTANT4 = 4;
    final int CONSTANT5 = 5;
    int constantFolding = 0;

    constantFolding = 4 * 5;
    constantFolding = CONSTANT4 * CONSTANT5;

    // Relevant Bytecode (the "4 * 5" operation is shortened to "20" at compile time)
    bipush 20
    istore 5
    bipush 20
    istore 5
